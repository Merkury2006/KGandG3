# üéØ Affine Transformations 3D

–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –∞—Ñ—Ñ–∏–Ω–Ω—ã—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π –≤ 3D-–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ. –†–µ–∞–ª–∏–∑—É–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ, –ø–æ–≤–æ—Ä–æ—Ç 
–∏ –ø–µ—Ä–µ–Ω–æ—Å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –º–∞—Ç—Ä–∏—Ü –∏ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–æ–≤.

## üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

~~~java
import vsu.cs.AffineBuilder;
import javax.vecmath.Point3d;

Point3d point = new Point3d(1, 1, 1);
Point3d result = new AffineBuilder()
    .translate(10, 5, 0)
    .rotateZ(Math.PI / 4)
    .scale(2, 1, 1)
    .transform(point);
~~~
## –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
### –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
~~~java 
.scale(2, 2, 2)        // –ø–æ –≤—Å–µ–º –æ—Å—è–º
.scaleX(3)             // —Ç–æ–ª—å–∫–æ –ø–æ X
.scaleY(2)             // —Ç–æ–ª—å–∫–æ –ø–æ Y  
.scaleZ(1.5)           // —Ç–æ–ª—å–∫–æ –ø–æ Z
.scaleUniform(2)       // —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –º–∞—Å—à—Ç–∞–±
~~~
### –ü–æ–≤–æ—Ä–æ—Ç

~~~java
.rotateX(Math.PI / 2)  // –º–∞—Ç—Ä–∏—á–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ X
.rotateY(Math.PI / 4)  // –º–∞—Ç—Ä–∏—á–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ Y
.rotateZ(Math.PI / 6)  // –º–∞—Ç—Ä–∏—á–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ Z

.rotateXQuat(Math.PI / 2)  // –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ X
.rotateYQuat(Math.PI / 4)  // –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ Y
.rotateZQuat(Math.PI / 6)  // –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ Z
~~~
### –ü–µ—Ä–µ–Ω–æ—Å
~~~java 
.translate(10, 5, 0)   // –ø–æ –≤—Å–µ–º –æ—Å—è–º
.translateX(10)        // —Ç–æ–ª—å–∫–æ –ø–æ X
.translateY(5)         // —Ç–æ–ª—å–∫–æ –ø–æ Y
.translateZ(3)         // —Ç–æ–ª—å–∫–æ –ø–æ Z
~~~

### –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π
~~~java
new AffineBuilder()
    .translate(5, 0, 0)
    .rotateY(Math.PI / 4)
    .scale(2, 1, 1)
    .rotateZ(Math.PI / 6)
    .translate(0, 3, 0)
    .transform(point);
~~~
